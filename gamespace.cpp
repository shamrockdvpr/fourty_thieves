#include "gamespace.h"

// randomly shuffles main deck
void gamespace::shuffle(stack<card> &inputDeck)
{
    // create two dummy decks
    stack<card> firstHalf;
    stack<card> secondHalf;

    // create a random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> deckChooser(0,1);

    // cut the deck
    for (int i = 0; i < 52; ++i){
        firstHalf.push(inputDeck.pop());
        secondHalf.push(inputDeck.pop());
    }

    // while one of the decks has cards, choose a deck at random and deal back into main deck
    while(!firstHalf.isEmpty() && !secondHalf.isEmpty()){
        int randBit = deckChooser(gen);
        if (randBit) inputDeck.push(firstHalf.pop());
        else inputDeck.push(secondHalf.pop());
    }

    // see if any cards are left over and deal all remaining back into main deck
    if (firstHalf.isEmpty()){
        while (!secondHalf.isEmpty())
        {
            inputDeck.push(secondHalf.pop());
        }  
    }
    else{
        while (!firstHalf.isEmpty())
        {
            inputDeck.push(firstHalf.pop());
        }
    }
}

// builds gamespace
gamespace::gamespace() 
    : 
    // creates all decks
    decks{{104}, // stock Index pos - 0
          {104}, // waste Index pos 1
          {13}, {13}, {13}, {13}, {13}, {13}, {13}, {13}, // foundations - Index pos 2 - 9
          {104}, {104}, {104}, {104}, {104}, {104}, {104}, {104}, {104}, {104} //tableaus Index Pos 10 - 19
    },
    // creates an empty history
    gameHistory(),
    // creates an empty hints tree
    hints()
{
    // sets score to zero
    score = 0;

    // populates stock with 2 full decks
    for (int i = 0; i < 52; ++i){
        card *newCard = new card((i % 13 + 1), (i / 13));
        decks[0].push(*newCard);
        delete newCard;
    }
    for (int i = 0; i < 52; ++i){
        card *newCard = new card((i % 13 + 1), (i / 13));
        decks[0].push(*newCard);
        delete newCard;
    }

    // shuffle three times for proper randomness
    shuffle(decks[0]);
    shuffle(decks[0]);
    shuffle(decks[0]);

    // deals 4 cards to each tableau
    for (int i = 0; i < 4; ++i){
        for (int j = 0; j < 10; ++j){
            decks[j + 10].push(decks[0].pop());
        }
    }
}

// returns an integer that corresponds to the score generated by a potential move
// moves are being scored at different amounts to encourage certain moves in the hints
// for example, we want to encourage starting foundations and discourage moving foundations away
int gamespace::calculateScoreInc(stack<card> &startDeck, stack<card> &destDeck)
{

    // scoring priority
    // most encouraged moves are to a foundation, especially starting or finishing one
    // next is moving a card to the tableau from the stock or waste
    // next is drawing a new card
    // next is inter tableau movement
    // discouraged is moving away from a foundation
    // this type of move isn't illegal but ill advised, and the ai won't do it correctly

    // uses the difference in memory address from the current deck and start of decks array to determine what type of deck it is
    int startDeckType = &startDeck - decks;
    int destDeckType = &destDeck - decks;

    // 10 points if the move is to the waste pile
    if (destDeckType == 1) return 10;

    // 15 points for a move to a tableau from stock or waste
    else if (startDeckType < 2 && (destDeckType >= 10 && destDeckType < 20)) return 15;

    // tableau to tableau move is 5 points
    else if ((startDeckType >= 10 && startDeckType < 20) && (destDeckType >= 10 && destDeckType < 20)) return 5;

    // we want to discourage moving away from a foundation, so the score is negative
    else if (startDeckType >= 2 && startDeckType < 10) return -5;

    // if the destination is a foundation there are some special cases
    else if (destDeckType >= 2 && destDeckType < 10) {
        // 25 points for starting a new foundation pile
        if (startDeck.peek().getNumber() == 1 && destDeck.isEmpty()) return 25;

        // 50 points for finishing off a foundation pile
        else if (startDeck.peek().getNumber() == 13) return 50;

        // otherwise, general move to a foundation is 20 points
        return 20;
    };
    
    //if the move has reached this far, the game wont be sure what to do with it, return 0 as a default
    return 0;
}

// returns true if a potential move is valid
bool gamespace::isValid(stack<card> &startDeck, stack<card> &destDeck)
{
    // it is impossible to deal cards from an empty deck or to deal cards to a full deck
    if (startDeck.isEmpty()) return false;
    if (destDeck.isFull()) return false;

    // uses the difference in memory address from the current deck and start of decks array to determine what type of deck it is
    int startDeckType = &startDeck - decks;
    int destDeckType = &destDeck - decks;

    //using the type of deck that the destination is, decide which set of rules to follow

    // if the destination is the stock pile it is invalid
    if (destDeckType == 0) return false;

    // if the destination is the waste pile and the start is the stock, the move is valid
    if (destDeckType == 1 && startDeckType == 0) return true;

    // destination is a foundation
    if (10 > destDeckType && destDeckType >= 2){

        // if the foundation isnt empty
        if (!destDeck.isEmpty()){
            // if the suits dont match
            if (destDeck.peek().getEnumSuit() != startDeck.peek().getEnumSuit()) return false;

            // if the foundation isnt empty and the new card is in ascending order move is valid
            else if ((startDeck.peek().getNumber() - destDeck.peek().getNumber() == 1))
                return true;
        }

        // if the foundation is empty and the card being inserted is  an ace the the move is  valid
        if (destDeck.isEmpty() && startDeck.peek().getNumber() == 1) return true;

        // if we dont pass all the tests, the move is invalid
        return false;
    }


    // if the destination is a tableau
    if (destDeckType >= 10){
        // if the tableau is empty, any card is valid
        if (destDeck.isEmpty()) return true;

        // if the suits match and the numbers are descending the move is valid
        else if (destDeck.peek().getEnumSuit() == startDeck.peek().getEnumSuit() && (destDeck.peek().getNumber() - startDeck.peek().getNumber() == 1))
            return true;

        // if no condtion was met the move is invalid
        return false;
    }
    // if we passed all the tests, then the move is assumed to be true
    return false;
}

void gamespace::moveCards(std::string startString, std::string destString)
{
    // determine if move is valid
    // calculate change in score
    // create new move obj
    // add to move list
    // increm score

    // creates two pointers for storing decks
    stack<card> *startDeck;
    stack<card> *destDeck;

    // extract the first character from the input
    char* firstChar = &startString[0];
    
    // parse for start deck, uses the fact that a char is an interger ascii value
    switch (*firstChar)
    {
        // first char is f
        case 102:{
            // get second character for specific deck
            char* secondChar = &startString[1];
            startDeck = &decks[*secondChar - '0' + 2];
            break;
        }

        // first char is t
        case 116:{
            char* secondChar = &startString[1];
            startDeck = &decks[*secondChar - '0' + 10];
            break;
        }
        // first char is s
        case 115:{
            // only one stock deck
            startDeck = &decks[0];
            break;
        }
        // first char is w
        case 119:{
            // only one waste deck
            startDeck = &decks[1];
            break;    
        }
        // if this is reached theres been a serious error with the regex
        default: {throw std::out_of_range("Deck not available");};
    }

    // get the destination
    firstChar = &destString[0];

    // parse for second deck
    switch (*firstChar)
    {
        // first char is f
        case 102:{
            char* secondChar = &destString[1];
            destDeck = &decks[*secondChar - '0' + 2];
            break;}

        // first char is t
        case 116:{
            char* secondChar = &destString[1];
            destDeck = &decks[*secondChar - '0' + 10];
            break;}
        
        // first char is w
        case 119:{
            destDeck = &decks[1];
            break;}  
        
        // first char is s, this will be an invalid move but to better control errors we will pass it anyway
        case 115:{
            destDeck = &decks[0];
            break;
        }
        default: {throw std::out_of_range("Deck not available");};
    }

    // determine if move is valid, if it is, move cards, add move to history, update score
    if (isValid(*startDeck, *destDeck)){
        // calculate score and generate a move object
        int scoreInc = calculateScoreInc(*startDeck, *destDeck);
        move* newMove = new move(*startDeck, *destDeck, scoreInc);

        // move cards and add move to history, update score, clean up memory
        destDeck->push(startDeck->pop());
        gameHistory.push(*newMove);
        updateScore(scoreInc);
        delete newMove;
    }

    // let the user know their move was invalid
    else {

        throw std::invalid_argument("\nMove from " + startString + " to " + destString + " is invalid\n");
    }
}

// undoes previous move
void gamespace::undo()
{
    // if there are moves to undo
    if (!gameHistory.isEmpty()){
        move undoMove = gameHistory.pop();
        // push the top card from the destination to the start, the reverse of how it was done in the move function
        (undoMove.getSource())->push((undoMove.getDestination())->pop());
        updateScore(-(undoMove.getScore()));
    }
    else throw std::invalid_argument("No moves to undo");
}

// creates a tree of every possible move and ranks based on score
void gamespace::generateMovesTree()
{
    // if the tree isn't empty, destroy it
    if (!hints.isEmpty()){
        hints.destroyTree();
    }

    // iterate over every deck and check validity of move, if it is a valid move, add to hints tree
    for (int i = 0; i < decksCount; ++i){
        for (int j = 0; j < decksCount; ++j){
            if (isValid(decks[i], decks[j])){
                int scoreInc = calculateScoreInc(decks[i], decks[j]);
                move *newMove = new move(decks[i], decks[j], scoreInc);
                hints.insert(*newMove);
                delete newMove;
            }
        }
    }
}

// returns true if there are moves left, false if not
bool gamespace::movesLeft()
{
    move *newMove = new move(hints.getMax());
    if (newMove->getScore() < 0) return false;

    return !hints.isEmpty();
}

// returns true if game has been won, and false if not
bool gamespace::determineOutcome()
{
    for (int i = 0; i < decksCount; ++i){
        if (i >= 2 && i < 10){
            // if it is a foundation that is full and the top card isnt a king, something has gone wrong
            if (decks[i].isFull() && decks[i].peek().getNumber() != 13) return false;
        }
        else if (!decks[i].isEmpty()) return false;
    }
    return true;
}

// emptys all decks and histories, resets score to zero
void gamespace::resetGamespace()
{
    for (int i = 0; i < decksCount; ++i){
        decks[i].initializeList();
    }
    gameHistory.initializeList();
    if (!hints.isEmpty()) hints.destroyTree();
    resetScore();

    // redeals to stock pile

    // populates stock with 2 full decks
    for (int i = 0; i < 52; ++i){
        card *newCard = new card((i % 13 + 1), (i / 13));
        decks[0].push(*newCard);
        delete newCard;
    }
    for (int i = 0; i < 52; ++i){
        card *newCard = new card((i % 13 + 1), (i / 13));
        decks[0].push(*newCard);
        delete newCard;
    }

    // shuffle three times for proper randomness
    shuffle(decks[0]);
    shuffle(decks[0]);
    shuffle(decks[0]);

    // deals 4 cards to each tableau
    for (int i = 0; i < 4; ++i){
        for (int j = 0; j < 10; ++j){
            decks[j + 10].push(decks[0].pop());
        }
    }
}

// get best move from hints tree, play move, increase score, add move to gameHistory
void gamespace::getHint()
{
    if (!hints.isEmpty()){
        move *newMove = new move(hints.getMax());
        newMove->getDestination()->push(newMove->getSource()->pop());
        updateScore(newMove->getScore());
        gameHistory.push(*newMove);
    }
}

// prints game in fancy console gui form
std::ostream &operator<<(std::ostream &out, const gamespace game)
{
    // outputs top of box
    out << "+------------------------------------------------------------+\n";

    // outputs score
    out << "|" << std::setw(26) << "Score: " << std::setw(5) << game.score << std::setw(30) << "|";

    // outputs bottom of scoreboard
    out << "\n|------------------------------------------------------------|";
    
    // right justifies stock , allows for empty deck
    out << "\n|" << std::setw(53) << "Stock: ";
    if (!game.decks[0].isEmpty()){
        out << game.decks[0].peek();
    } else{
        out << "[   ]";
    }

    // right justifies waste , allows for empty deck
    out << "  |\n|" << std::setw(53) << "Waste: ";

    if (!game.decks[1].isEmpty()){
        out << game.decks[1].peek();
    } else{
        out << "[   ]";
    }

    // creates a blank line
    out << "  |\n|" << std::setw(65) << "|\n|  ";
    

    // outputs both lines of foundations
    for (int i = 0; i < 4; ++i){
        out << "F" << i << ": ";

        if (!game.decks[i + 2].isEmpty()){
            out << game.decks[i + 2].peek();
        } else{
            out << "[   ]";
        }

        out << "   ";
    }
    out << std::setw(15) << "|\n|  ";

    for (int i = 4; i < 8; ++i){
        out << "F" << i << ": ";

        if (!game.decks[i + 2].isEmpty()){
            out << game.decks[i + 2].peek();
        } else{
            out << "[   ]";
        }

        out << "   ";
    }
    out << std::setw(13) << "|\n|";

    // blank line
    out << std::setw(65) << "|\n|  ";

    // outputs tableaus
    for (int i = 0; i < 10; ++i){
        // divides output into two lines
        if (i == 5) out << "   |\n|  ";
        out << "T" << i << ": ";

        if (!game.decks[i + 10].isEmpty()){
            out << game.decks[i + 10].peek();
        } else{
            out << "[   ]";
        }

        out << "  ";
    }
    out << "   |";
    // bottom of box
    out << "\n+------------------------------------------------------------+\n";
    return out;
}